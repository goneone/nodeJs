-------------페이징처리----------------------------------------------------
1.동적 페이지네이션 - 페이지 별로 데이터를 나누어 받는 방식 - ex) 네이버 카페 같은건가?
2.정적 페이지네이션 - 전체 데이터를 한 번에 받는 방식.

이번 엑셀 대용량 다운로드는 전체 데이터(최대1만건)를 다 받아와서 그거를 엑셀에 넣는 작업.
엑셀 다운로드 버튼을 눌렀을때 조회버튼의 로직을 타서 전체 데이터를 조회하도록 함.
top API중 엑셀다운로드 공통 API인 Common_ExcelExport(arg0, arg1, arg2)는
arg0 : 테이블 아이디
arg1 : 팝업 여부(팝업에 위치한 테이블만 true, 아니면 false)
arg2 : 조회한 데이터 array
ex) common_ExcelExport('HLACRTM010M_TableView', false, ret.dto.SUB)
ex2)Top에서 JLSMSDM001M (기타기기관리) 1227line

------------------------------------------------------------------------------


로드밸런싱과 세션 클러스터링
로드밸런싱
하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러대의 서버가 분산처리하여
서버의 로드율 증가, 부하량, 속도저하등을 고려하여 적절히 분산처리를 해결해 주는 서비스

로드밸런싱 서비스 방식
네트워크 상단의 L4 스위치가 존재하며 서버로 들어오는 패킷을 실서버로 균일하게 트래픽
부하를 분산시킨다.
(ex 실서버 중 정상적으로 작동하지 않는 경우 이를 감지하여 정상적으로 작동하는 서버로 부하를 분산시킨다.
)

cluster - 무리, 송이, 떼, 집단

클러스터링?
여러대의 서버가 동시에 한가지 업무를 수행하도록 만드는 것.
예를 들어 DB가 한대 있는데 이 한대가 뻗으면 시스템 장애가 난다.
만약 2대를 클러스터링 해 놓고 각각의 역할을 수행하다가 한놈이 뻗으면 나머지 한놈이
그 역할을 대신 수행하도록 하면 위와 같은 문제를 해결하면서 지속적인 서비스를 제공해줄 수 있게 됨.

세션 클러스터링?
was가 2대 이상 설치되어 있을 경우 동일한 세션으로 세션관리 하는 것을 의미한다.
예를 들어 L4 스위치를 통해 2대 이상의 was가 연결되어 있을 경우, 일반적으로는 사용자는 접속했던
was로 L4 스위치가 접속을 유도해주지만 하나의 WAS에서 허용된 동접수를 초과한 접속이
발생할 경우 다른쪽으로의 접속을 유도해주게 된다. 그럴 경우, 기존 WAS의 세션이 아닌
새로이 접속된 WAS로 세션이 이루어지고 그럴 경우 세션에 대한 처리 불일치가 발생한다.
그래서 각 WAS에 대한 세션을 하나의 세션으로 관리하게 함으로써 설사 사용자가 기존에 접속했던 WAS가 아닌
새로운 WAS로 접속하더라도 세션은 하나로 관리되기 때문에 세션에 대한 불일치가 발생하지 않게한다.
보통 세션 클러스터링은 WAS 설정으로 세팅할 수 있다.

로드밸런싱과 세션 클러스터링 차이점
로드 밸런싱은 클러스터링된 was의 한쪽에 부담이 가지 않게 하기 위해서
분산 시켜주는 역할을 말한다. 보통 스위치 단에서 이루어짐.
세션 클러스터링은 한쪽 부담이 가지않게 분산을 한다기 보단 하나의 서버의 장애를 방지하기 위해
임시방편 역할을 한다.

---------------------------------------------------------------------------
call by value 와 call by reference

---------------------------------------------------------------------------
메모리 구조
운영체제가 프로그램을 실행하는데 메모리관리를 어떻게하나?
동적관리는 무엇이고 왜필요한가?
프로그램을 실행할 때 프로그램 실행을 위해 메모리 공간이 요구된다
(상수,변수, 문자열등을 선언할 때에 필요..)
이러한 메모리공간은 운영체제가 관리를 해줌.
어떻게?
데이터, 힙, 스택로 구분지어서 관리해줌.

데이터영역은 전역변수나 static 변수를 저장하기 위한 공간
스택은 지역변수와 매개변수를 저장하기 위한 공간 (그외에다른것도 저장되는데 변수입장에서 봤을때 말하는거임)

**컴파일 타임에 함수에서 요구하는 스택의 크기가 결정되어야 한다.
------------------------------------------------------------------------------
암호화기법
개인키 (DES) - 대칭 암호 기법
공개키 (Public Key) - 비대칭 암호 기법
aes 는 대칭키 암호기법임. (키를 서로 주고받아 가지고있으니까)
------------------------------------------------------------------------------
Marshal
다른 기종의 컴퓨터 간의 통신을 위해서 서로간의 형식을 맞춘 것을 의미한다.
마샬링은 보통 A언어로 작성된 프로그램의 출력 매개변수들을
B언어로 작성된 프로그램의 입력으로 전달해야하는 경우에 필요하다.
언마샬링은 마샬링을 통해서 보내진 데이터들을 원래 구조로 복원 시키는 것이다.

Marshal/Unmarshal
Xml – 자바,파이썬 등 어떤 언어든 공통적으로 사용 할 수 있는 언어가 xml이다.
그래서 자바에서 String name = “엄욱남” 이거를 다른데로 전송하거나 하기 위해서 xml로 바꿔주는 것을 마샬링이라 한다.
Ex)po에서 top에게 던져주기 위해 마샬링을한다. 마샬링 방식은 json형식으로. Top와 po가 서로 미리 약속을 해둠.
top에서 Json.parser(msg) 이런식으로 하는 것을 언마샬링이라고 한다.

------------------------------------------------------------------------------
DOF(data object factory)
데이터베이스에 접근하여 데이터를 조회하거나 조작하는데 사용하는 객체
DB를 처리할 때 JDBC를 이용할 경우 사용자가 직접 구현해야 했던 여러 가지 반복적인 작업들을 대신해줌으로써 개발자가 편리한 개발이 가능하도록 한다.
***쿼리문과 TARGET DO가 맵핑 되는 원리.
컬럼명이 TARGET DO 안에 정의되어야 쿼리문에 전달이 됨.
Ex).select cardtype, cardname from T_ISS_POLICY 이 셀렉트문에서 cardtype과 cardname이 target do 안에 정의 되어야 쿼리문에 전달이 됨.

이 부분 다음주 회사가서 저번주에알게되서 공책에 적은 내용 추가 예정


------------------------------------------------------------------------------
WAS가 없으면 왜 웹어플리케이션을 실행 할 수 없을까?
was는 웹어플리케이션(웹 시스템, 웹서비스)을 실행할 수 있는 기초적인 환경을 제공해줌.
was를 웹에서의 운영체제(os)라고 생각 하자.
*web에서 사용되어지는 jsp나 servlet 등이 실행 되기 위해서는 was가 필요함

현재 커넥트 프로젝트 was 경로 -
C:\Users\Tmax\Downloads\apache-tomcat-8.5.34\bin
쓰는 was 버전 - 8.5.34

포트번호 변경법 -
C:\Users\Tmax\Downloads\apache-tomcat-8.5.34\conf
경로에서 server.xml파일에서 8080부분을 원하는 포트번호로 변경.
자세한건 인터넷 검색

***servlet이란?
url요청을 처리하는 프로그램이라고 생각하면 된다.
자바 웹 어플리케이션의 구성요소 중 동적인 처리를 하는 프로그램의 역할
서블릿을 정의해보면
*서블릿은 WAS에서 동작하는 java 클래스이다
서블릿은 HttpServlet을 상속받아야한다.
서블릿과 jsp로부터 최상의 결과를 얻으려면, 웹 페이지를 개발할 때
이 두가지를 조화롭게 상요해야 한다.
ex) 웹 페이지를 구성하는 화면(HTML)은 jsp로 표현하고 복잡한 프로그래밍은 서블릿으로 구현


*이클립스는 runtime으로 설정된 was에 밑의 규칙의 url로 servlet을 실행한다
http://localhost:8080/{프로젝트이름}/{URL Mapping 값}

*웹브라우저가 get메서드 방식으로 요청을 보내면
servlet의 doGet메서드가 호출된다.
------------------------------------------------------------------------------
servlet의 작성방법.

버전에 따라 두가지로 나눠짐.
3.0에서 사용하는방법
web.xml파일 사용하지 않음.
자바 어노테이션을 사용
3.0 미만에서 사용하는 방법
servlet을 등록할 때 web.xml파일에 등록



3.0미만 버전에서 web.xml의 동작 방식.
<servlet>
    <description></description>
    <display-name>TenServlet</display-name>
    <servlet-name>TenServlet</servlet-name>
    <servlet-class>exam.TenServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>TenServlet</servlet-name>
    <url-pattern>/ten</url-pattern>
  </servlet-mapping>

  여기서 url이 /ten 이라고 요청이 들어오면
  여기서 못찾으면 404페이지를 보여줌.
  존재하면 servlet-name을 확인함. 이이름을 가지고있으니까
  <servlet>태그 안에서 똑같은 이름의 servlet 이름을 찾음.
  TenServlet을 찾아서 실제로 exam.TenServlet을 실행시킴
  3.0이상 버전에서는 어노테이션이 이런일들을 대신 해줌.
------------------------------------------------------------------------------
servlet의 생명 주기
WAS는 서블릿 요청을 받으면 해당 서블릿이 메모리에 있는지 확인한다.
IF(메모리에 없음) {
  해당 서블릿 클래스를 메모리에 올림
  init() 메소드를 실행.
}
  service() 메소드를 실행
was가 종료되거나, 웹 어플리케이션이 새롭게 갱신될 경우 destroy() 메소드가 실행된다.

public LifecycleServlet() {
        System.out.println("LifecycleServlet 생성!!");
    }

public void init(ServletConfig config) throws ServletException {
	System.out.println("init 호출!!");
}

()요청된 객체가 메모리에 없으면 메모리에 올림.
메모리에 올라간 후에는
메모리에 있으면 service라는 메소드만 호출함.

서블릿이 수정되면. 메모리에 올라가있는 서블릿 객체는 사용 될수 없을 것이다
그 때 destroy 메소드가 호출됨.
그리고 브라우저에서 호출해보면
다시 객체를 생성하고 init 호출하고 service 호출함.)
------------------------------------------------------------------------------
service() 메소드는 어떻게 동작하나?
service(request, response) 메소드
HttpServlet에 이미 servlet 메소드가 이미 구현이 되어 있는 상태
내가 만든 클래스가 service라는 메소드가 가지고 있지 않다면
부모 클래스의 service가 실행될것이다 (상속~)

HttpServlet 서블릿에서 service메소드가 없는데도 실행이 되는 이유
이클립스에서 HelloServlet 서블릿을 보면
public class HelloServlet extends HttpServlet {
HttpServlet을 상속 받았고 따로 service 메소드를 오버라이딩 하지 않았기 때문에
HttpServlet의 service() 메서드가 실행이 되는 것이다.
------------------------------------------------------------------------------
HttpServletRequest 와 HttpServletResponse
클라이언트로부터 요청이 들어오면 WAS는 HttpServletRequest 와 HttpServletResponse 객체를 생성한다.


**enq배치는 기기가 살아있느지 확인하는 배치.
완전새로운 사업장이면 -> 기기등록부터. 붙었다는 의미는애니링크상에서 flag를 바꿨을떄.
db가죽으면 업데이트를 못치니까.

프로토콜
top -> po 는 http
po랑 애니링크도 TCP
애니링크랑 기기는 tcp
------------------------------------------------------------------------------
*쓰레드와 프로세스
운영체제란 컴퓨터 하드웨어를 사용할수 있게 해주는 프로그램이다.
요즘 사용하는 운영체제는 동시에 여러가지 작업을 수행할 수 있다.
( 워드하면서 노래들으면서 웹서핑하면서 )
ctrl+alt+del 누르면 현재 실행중인 프로세스를 볼 수 있음.
여기서 프로세스란 현재 실행되고 있는 프로그램을말함.
JVM도 워드프로세스, 인터넷,  멜론 등과 같이 하나의 프로세스라 할 수 있음.
워드치다보면 자동으로 맞춤법 검사 하는데. 그러한 프로세스 내의 여러 개의 흐름.
그것을 쓰레드라 한다.
------------------------------------------------------------------------------
Class Loader란?
Class Loader는 자바 바이트코드를 읽어들여서 클래스 객체를 생성하는 역할을 담당

자바는 동적으로 클래스를 읽는다. 런타임 시에 모든 코드가 JVM에 링크, 로딩되는 것이다. 자바의 런타임 라이브러리인 rt.jar도 마찬가지다.
이러한 동적인 클래스 로딩을 담당하는 것이 Class Loader이며, 자바는 기본적으로 java.lang.ClassLoader라는 Class Loader를 제공한다.
역으로 동적으로 클래스를 로딩한다는 것은 JVM은 클래스에 대한 정보(메소드, 필드, 상속관계)를 가지고 있지 않다는 것을 의미한다.
이러한 정보 역시 동적으로 확인되며 검증한다.

------------------------------------------------------------------------------
클래스 로딩 방식
클래스 로딩 방식에는 load-time dynamic loading과 run-time dynamic loading이 있다.
load-time dynamic loading은 클래스를 로딩하는 과정에서 다시 필요한 클래스를 로딩한다.
예를 들어 HelloWorld 클래스 내에 System.out.println이 있다면 java.lang.System을 로딩할 것이다.
반면 run-time dynamic loading은 클래스 내 코드를 실행하는 과정에서 필요한 클래스를 로딩한다. Class.forName()을 사용하는 경우가 대표적이다.

------------------------------------------------------------------------------
동적인 클래스 로딩
자바는 동적으로 클래스를 읽어온다.
즉, 런타임에 모든 코드가 JVM에 링크된다.
모든 클래스는 그 클래스가 참조되는 순간에 동적으로 JVM에 링크되며, 메모리에 로딩된다. 자바의 런타임 라이브러리([JDK 설치 디렉토리]/jre/lib/rt.jar) 역시 예외가 아니다. 이러한 동적인 클래스 로딩은 자바의 클래스로더 시스템을 통해서 이루어지며, 자바가 기본적으로 제공하는 클래스로더는 java.lang.ClassLoader를 통해서 표현된다. JVM이 시작되면, 부트스트랩(bootstrap) 클래스로더를 생성하고, 그 다음에 가장 첫번째 클래스인 Object를 시스템에 읽어온다.

런타임에 동적으로 클래스를 로딩하다는 것은 JVM이 클래스에 대한 정보를 갖고 있지 않다는 것을 의미한다. 즉, JVM은 클래스의 메소드, 필드, 상속관계 등에 대한 정보를 알지 못한다. 따라서, 클래스로더는 클래스를 로딩할 때 필요한 정보를 구하고, 그 클래스가 올바른지를 검사할 수 있어야 한다. 만약 이것을 할 수 없다면, JVM은 .class 파일의 버전이 일치하지 않을 수 있으며, 또한 타입 검사를 하는 것이 불가능할 것이다. JVM은 내부적으로 클래스를 분석할 수 있는 기능을 갖고 있으며, JDK 1.1부터는 개발자들이 리플렉션(Reflection)을 통해서 이러한 클래스의 분석을 할 수 있도록 하고 있다.




클래스 로딩의 순서는?
1. Bootstrap Class Loader는 JVM이 초기화 시 필요한 클래스(jre/lib/rt.jar 등)를 로딩한다.
2. Extension Class Loader는 $JAVA_HOME/jre/lib/ext내 클래스를 로딩한다. (Bootstrap과 Extension을 묶어 Bootstrap으로 표현하는 경우도 있다)
3. System Class Loader는 애플리케이션이 사용하는 클래스를 로딩한다.
여기까지는 일반적인 자바 애플리케이션의 클래스 로딩이다.
만약 웹로직과 같은 애플리케이션 서버를 사용하는 경우 ServletContainerClassLoader나 ServletContextClassLoader 등이 추가로 존재하게 된다.
자바 스펙에 의해 Class Loader는 다음 조건을 충족해야 한다.
1. WEB-INF/lib보다 WEB-INF/classes를 먼저 로딩해야 한다. (의무사항)
2. war 파일 내부의 클래스를 컨테이너 레벨의 jar 파일보다 먼저 로딩한다. (권고사항)

-------

  개발을 하거나 WAS를 기동하면 ClassNotFoundException 을 많이 만나게 됩니다.


왜 클래스를 찾을 수 없는지 원리를 알아보기 위해 정리를 해보았습니다.


ClassLoader의 작동원리를 살펴보기 전에 먼저 알아야 할 용어를 정리하면.


Class - Java 프로그램을 컴파일하여 생성된 .class

Class 객체 - 일반객체를 만들기 위해 JVM 메모리에 로드된 .class에 대한 객체

일반 객체 - Class 객체로 생성한 객체


ClassLoader는 작성한 Java Byte Code를 JVM메모리상에 올려주는 역할을 하는 것이고, 프로그래머는 Class 객체를 이용하여 일반객체를 생성할 수 있습니다. 즉 메모리 내에서 Class 객체를 매개로 하여 일반객체를 생성합니다.


ClassLoader는 기본적으로 Unload 기능을 제공하지 않습니다.. GC에 의하여 자동 Unload되며, Static으로 선언된 경우에는 GC에서 Unload하지 않기 때문에 프로그래머는 항상 Static으로 선언된 클래스를 사용할 수 있습니다.





Java ClassLoader의 구조(Delegation Model, 위임구조)


Bootstrap ClassLoader - 모든 ClassLoader의 부모 ClassLoader

Extensions ClassLoader - Bootstrap ClassLoader를 상속하며, lib/ext 디렉토리에 있는 클래스를 로드

System-Classpath ClassLoader - Extensions ClassLoader를 상속하며, CLASSPATH에 잡혀 있는 모든 클래스, java.class.path 시스템 프라퍼티, -cp 혹은 -classpath에 잡혀 있는 모든 클래스를 로드


ps.구조도는 첨부하였습니다.



클래스 로더의 delegation model에서 클래스를 찾을 경우

Cache -> Parent -> Self 순서로 찾습니다.


클래스 생성을 요청받으면 먼저 Cache를 검색하여 이전에 요청이 있었는지 파악하며, 없을경우 상위 클래스 로더에서 찾습니다.

최상위 클래스로더인 Bootstrap ClassLoader 에도 없을 경우 작업한 소스의 경로에서 클래스를 찾아서 생성합니다.

출처: http://unabated.tistory.com/entry/JVM-ClassLoader의-작동원리 [랄라라]




클래스로더 - compile time이 아닌 run time에 class를 로딩할 수 있게 해주는 기술
